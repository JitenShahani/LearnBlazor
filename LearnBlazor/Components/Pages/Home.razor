<PageTitle>@ApplicationName</PageTitle>

<h1>Hello, world!</h1>

Welcome to your new app.

<_InfoBox HeaderText="Blazor Custom Element" Class="mt-3">
	<Body>
		<p>
			A custom element is a type of Web Component that lets developers define their own HTML tags with custom behavior. Instead of being limited to built‑in tags like `div` or `button`, you can create something like `my-counter` or `my-home` that encapsulates its own rendering logic, styles, and functionality.
		</p>
		<p>
			In Blazor, Custom Elements allow you to expose Razor components as these reusable HTML tags. Once registered, you can drop them into any HTML page (even outside Blazor routing), and the Blazor runtime will render the component inside that tag.
		</p>

		<Button Color="ButtonColor.Primary" Outline="true" Class="me-1 shadow-none" @onclick="LoadCustomElement">Launch Custom Element</Button>
	</Body>
</_InfoBox>

<_InfoBox HeaderText="Dependency Injection Demo">
	<Body>
		<p>
			On the first request, Blazor renders this page on the server (pre-rendering) and returns plain HTML to the browser.
			If you inspect the response in the Network tab, you’ll see the values that were generated by the scoped
			<code>ISampleData</code> service during that server render.
		</p>
		<p>
			When the SignalR connection is established, the component is hydrated and runs again on the Blazor circuit.
			Because the scoped service is re-instantiated for the interactive phase, values read directly from
			<code>ISampleData</code> can differ from what you saw in the pre-rendered HTML, but values stored with
			<code>[PersistentState]</code> are restored so they stay consistent across
			pre-rendering, hydration, and reconnection.
		</p>

		<hr />

		<p>Value fetched directly by calling ISampleData Service.</p>
		<p>Value 1: @SampleData.Value1</p>
		<p>Value 2: @SampleData.Value2</p>

		<p>Values fetched from ISampleData service but are persisted between pre-rendering and hydration and re-connection of SignalR.</p>
		<p>Value 1: @Value1</p>
		<p>Value 2: @Value2</p>

		<hr />

		<p>
			To see the pre-rendered HTML, press <kbd>F12</kbd> to open DevTools, go to the <strong>Network</strong> tab,
			press <kbd>Ctrl</kbd>+<kbd>R</kbd> to reload the page, then select the main <code>localhost</code> entry and
			open its <strong>Preview</strong> tab. This shows the HTML generated during pre-rendering, which can differ from
			the hydrated values shown in the live page when services are re-instantiated.
		</p>

	</Body>
</_InfoBox>

<_InfoBox HeaderText="Read Configuration Settings">
	<Body>
		<p>@_userName</p>
		<p>@_password</p>
		<p>@_accessToken</p>
	</Body>
</_InfoBox>

<_InfoBox HeaderText="Attribute Splatting">
	<Body>
		<p>
			When you build a custom Blazor component, you can’t automatically apply standard HTML element attributes like
			<code>class</code>, <code>style</code>, <code>id</code>, or <code>data-*</code>.
			Blazor provides a way to capture all unmatched attributes into a dictionary and then “splat” them onto an element
			inside your component.
		</p>

		<p>How it Works</p>
		<ul>
			<li>Capture Unmatched attributes</li>
			<ul>
				<li>
					Any attributes passed to the component that don’t match a defined <code>[Parameter]</code> property
					are collected into <code>AdditionalAttributes</code>.
				</li>
			</ul>
			<li>Splat them into an element</li>
			<ul>
				<li>Inside your component’s markup, you apply them with <code>@@attributes</code>.</li>
				<li>
					For example
					<code> @@&lt;input type="text" @@attributes="AdditionalAttributes" /&gt;</code>
					<pre>
						<code>
					@@
private Dictionary&lt;string, object&gt; _inputAttributes { get; set; } = new ()
{
	{ "placeholder", "Custom Placeholder" },
	{ "required", "required" },
	{ "class", "form-control shadow-none fw-bold fs-1" },
	{ "style", "color: purple;" },
	{ "value", "¡Hola Mundo!" }
};
						</code>
					</pre>
				</li>
			</ul>
		</ul>

		<_MyInputText AdditionalAttributes="_inputAttributes" />
	</Body>
</_InfoBox>

<_InfoBox HeaderText="Blazor Bootstrap Examples" />

<Alert Color="AlertColor.Primary" Dismissable="false" Class="mt-2">
	<Icon Name="IconName.Gem" Class="me-2" /> <strong>A simple primary alert</strong> with an icon.
</Alert>

<Alert Color="AlertColor.Primary" Dismissable="true" Class="mt-2">
	<h4 class="alert-heading">
		<Icon Name="IconName.InfoCircle" Class="me-2" />
		Well done!
	</h4>
	<p>
		Aww yeah, you successfully read this important alert message. This example text is going to run a bit longer
		so that you can see how spacing within an alert works with this kind of content.
	</p>
	<hr>
	<p class="mb-0">Whenever you need to, be sure to use margin utilities to keep things nice and tidy.</p>
</Alert>

<Accordion>
	<AccordionItem Active="true" Class="mt-2">
		<TitleTemplate>
			<Icon Name="IconName.HouseFill" Class="me-2" Size="IconSize.x3" /> Accordion Item #1
		</TitleTemplate>
		<Content>
			<strong>This is the first item's accordion body.</strong> It is shown by default,
			until the collapse plugin adds the appropriate classes that we use to style each element.
			These classes control the overall appearance, as well as the showing and hiding via CSS transitions.
			You can modify any of this with custom CSS or overriding our default variables.
			It's also worth noting that just about any HTML can go within the .accordion-body,
			though the transition does limit overflow.
		</Content>
	</AccordionItem>
	<AccordionItem>
		<Content>
			<strong>
				This is the second item's accordion body.</strong> It is hidden by default,
				until the collapse plugin adds the appropriate classes that we use to style each element.
				These classes control the overall appearance, as well as the showing and hiding via CSS transitions.
				You can modify any of this with custom CSS or overriding our default variables.
				It's also worth noting that just about any HTML can go within the .accordion-body,
				though the transition does limit overflow.
		</Content>
		<TitleTemplate>
			<Icon Name="IconName.PersonFill" class="me-2" Size="IconSize.x3" /> Accordion Item #2
		</TitleTemplate>
	</AccordionItem>
	<AccordionItem>
		<Content>
			<strong>
				This is the third item's accordion body.</strong> It is hidden by default,
				until the collapse plugin adds the appropriate classes that we use to style each element.
				These classes control the overall appearance, as well as the showing and hiding via CSS transitions.
				You can modify any of this with custom CSS or overriding our default variables.
				It's also worth noting that just about any HTML can go within the .accordion-body,
				though the transition does limit overflow.
		</Content>
		<TitleTemplate>
			<Icon Name="IconName.PhoneFill" Class="me-2" Size="IconSize.x3" /> Accordion Item #3
		</TitleTemplate>
	</AccordionItem>
</Accordion>

<div class="mt-3 mb-5">
	<h4>Loading Button Component</h4>

	<Button Type="ButtonType.Button"
			Color="ButtonColor.Primary"
			Outline="true"
			Class="me-1"
			@onclick="() => ButtonLoading (_saveButton!)"
			@ref="_saveButton">
		<LoadingTemplate>
			<Spinner Type="SpinnerType.Border" Size="SpinnerSize.Small" Color="SpinnerColor.Primary" /> Saving...
		</LoadingTemplate>
		<ChildContent>
			<Icon Name="IconName.Save2" /> Save Subscriber
		</ChildContent>
	</Button>
	<Button Type="ButtonType.Button"
			Color="ButtonColor.Primary"
			Outline="true"
			Class="me-1"
			@onclick="() => ButtonLoading (_cancelButton!)"
			@ref="_cancelButton">
		<LoadingTemplate>
			<Spinner Type="SpinnerType.Dots" Color="SpinnerColor.Primary" /> Cancelling...
		</LoadingTemplate>
		<ChildContent>
			<Icon Name="IconName.HandThumbsDown" /> Cancel
		</ChildContent>
	</Button>
	<Button Type="ButtonType.Button"
			Color="ButtonColor.Danger"
			Outline="true"
			Class="me-1"
			@onclick="() => ButtonLoading (_deleteButton!)"
			@ref="_deleteButton">
		<LoadingTemplate>
			<Spinner Type="SpinnerType.Grow" Size="SpinnerSize.Small" Color="SpinnerColor.Danger" /> Deleting...
		</LoadingTemplate>
		<ChildContent>
			<Icon Name="IconName.HandThumbsUp" /> Delete Subscriber
		</ChildContent>
	</Button>
</div>

@page "/"
@rendermode InteractiveServer
@inject IJSRuntime JSRuntime
@inject ISampleData SampleData
@inject IConfiguration Configuration
@code {
	private Button? _saveButton;
	private Button? _cancelButton;
	private Button? _deleteButton;

	// Store Service Values
	[PersistentState]
	public int? Value1 { get; set; }

	[PersistentState]
	public int? Value2 { get; set; }

	// Store Configuration values
	private string _userName = string.Empty;
	private string _password = string.Empty;
	private string _accessToken = string.Empty;

	// Attribute Splatting
	private Dictionary<string, object> _inputAttributes { get; set; } = new ()
	{
		{ "placeholder", "Custom Placeholder" },
		{ "required", "required" },
		{ "class", "form-control shadow-none fw-bold fs-1" },
		{ "style", "color: purple;" },
		{ "value", "¡Hola Mundo!" }
	};

	protected override void OnInitialized ()
	{
		_userName = $"User Name: {Configuration["User:FirstName"]} {Configuration["User:LastName"]}";
		_password = $"Password: {Configuration["User:Password"]}";
		_accessToken = $"API Key: {Configuration["AccessToken"]}";

		Value1 ??= SampleData.Value1;
		Value2 ??= SampleData.Value2;

		base.OnInitialized ();
	}

	private async Task ButtonLoading (Button button)
	{
		button.ShowLoading ();

		await Task.Delay (2000);

		button.HideLoading ();
	}

	private async Task LoadCustomElement ()
	{
		await JSRuntime.InvokeVoidAsync ("open", "/example.html", "_blank");
	}
}